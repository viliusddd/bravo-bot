import supertest from 'supertest'
import createTestDatabase from '@tests/utils/createTestDatabase'
import {createFor} from '@tests/utils/records'
import {omit} from 'lodash/fp'
import {fakeMessage, messageMatcher} from './utils'
import createApp from '@/app'

const db = await createTestDatabase()
const app = createApp(db)

// builds helper function to create messages
const createMessages = createFor(db, 'message')

afterEach(async () => {
  // clearing the tested table after each test
  await db.deleteFrom('message').execute()
})

// close the database connection after all tests
// For SQLite, this is not necessary, but for other databases, it is.
afterAll(() => db.destroy())

// This is not called "contoller.spec.ts" because we are specifying what this
// entire module should do, not just the controller.

// This could be moved to root-level tests folder, however, nearly always
// breaking tests here means issues in the messages module, so we are colocating
// it with the module.
describe('GET', () => {
  it('should return an empty array when there are no messages', async () => {
    // ACT (When we request...)
    const {body} = await supertest(app).get('/messages').expect(200)

    // ASSERT (Then we should get...)
    expect(body).toEqual([])
  })

  it('should return a list of existing messages', async () => {
    // ARRANGE (Given that we have...)
    await createMessages([
      // we have a function that spits out a generic fake message
      fakeMessage(),

      // we generate a slightly different message
      // in this function call we provide what should
      // be different from the our default generic message
      fakeMessage({
        messageStr: 'You did really well 1!'
      })
    ])

    // ACT (When we request...)
    const {body} = await supertest(app).get('/messages').expect(200)

    // ASSERT (Then we should get...)
    expect(body).toEqual([
      messageMatcher(),
      messageMatcher({
        messageStr: 'You did really well 1!'
      })
    ])

    // This is same as:
    // expect(body).toEqual([
    //   {
    //     id: expect.any(Number), // we do not care about the exact id
    //     title: 'My Title', // our default title, content generated by fakeMessage
    //     content: 'Some Content',
    //   },
    //   {
    //     id: expect.any(Number),
    //     title: 'Title 2', // our custom title
    //     content: 'Other Content',
    //   },
    // ]);
  })
})

describe('GET /:id', () => {
  it('should return 404 if message does not exist', async () => {
    // ACT (When we request...)
    const {body} = await supertest(app).get('/messages/2912').expect(404)

    // ASSERT (Then we should get...)
    // Some error message that contains "not found".
    // Instead of stating the exact error message, we use a
    // regular expression to draw slightly more flexible boundaries
    // around our expectations. If we wanted to slightly change
    // our error message in code, we would not want these tests to break,
    // as long as the error message still contains "not found" in some
    // form: "MessageNotFound", "Not found", "Message was not found"...
    expect(body.error.message).toMatch(/not found/i)
  })

  it('should return an message if it exists', async () => {
    // ARRANGE (Given that we have...)
    await createMessages([
      fakeMessage({
        id: 1371
      })
    ])

    // ACT (When we request...)
    const {body} = await supertest(app).get('/messages/1371').expect(200)

    // ASSERT (Then we should get...)
    expect(body).toEqual(
      messageMatcher({
        id: 1371
      })
    )
  })
})

describe('POST', () => {
  it('should return 400 if messageStr is missing', async () => {
    // ACT (When we request...)
    const {body} = await supertest(app)
      .post('/messages')
      .send(omit(['messageStr'], fakeMessage({})))
      .expect(400)

    // ASSERT (Then we should get...)
    expect(body.error.message).toMatch(/messageStr/i)
  })

  it('does not allow to create a message with empty messageStr', async () => {
    const {body} = await supertest(app)
      .post('/messages')
      .send(fakeMessage({messageStr: ''}))
      .expect(400)

    expect(body.error.message).toMatch(/messageStr/i)
  })

  it('should return 201 and created message record', async () => {
    const {body} = await supertest(app)
      .post('/messages')
      .send(fakeMessage())
      .expect(201)

    expect(body).toEqual(messageMatcher())
  })
})

describe('PATCH /:id', () => {
  it('returns 404 if message does not exist', async () => {
    const {body} = await supertest(app)
      .patch('/messages/123456')
      .send(fakeMessage())
      .expect(404)

    expect(body.error.message).toMatch(/not found/i)
  })

  it('allows partial updates', async () => {
    const id = 137234
    await createMessages([
      fakeMessage({
        id
      })
    ])

    const {body} = await supertest(app)
      .patch(`/messages/${137234}`)
      .send({messageStr: 'Job well done!'})
      .expect(200)

    expect(body).toEqual(
      messageMatcher({
        id,
        messageStr: 'Job well done!'
      })
    )
  })

  it('persists changes', async () => {
    const id = 41512
    await createMessages([fakeMessage({id})])

    await supertest(app)
      .patch(`/messages/${id}`)
      .send({messageStr: 'Job well done!'})
      .expect(200)

    const {body} = await supertest(app).get('/messages/41512').expect(200)

    expect(body).toEqual(
      messageMatcher({
        messageStr: 'Job well done!'
      })
    )
  })
})

describe('DELETE', () => {
  it('returns 404 if message does not exist', async () => {
    const {body} = await supertest(app).delete('/messages/123456').expect(404)

    expect(body.error.message).toMatch(/not found/i)
  })

  it('returns 204 on successfull deletion', async () => {
    const id = 123
    await createMessages([fakeMessage({id})])

    await supertest(app).delete('/messages/123').expect(204)
  })

  it('returns no body content on success', async () => {
    const id = 123
    await createMessages([fakeMessage({id})])

    const record = await supertest(app).delete('/messages/123')
    expect(record.body).toEqual({})
  })
})
